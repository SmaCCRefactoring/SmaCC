"
SmaCCParseNode is an abstract class that represents parse nodes generated by SmaCC.

Subclasses must implement the following messages:
	visitor-double dispatching
		acceptVisitor:

Instance Variables:
	attributes	<Dictionary>	a dictionary that holds special properties for each node
	parent	<SmaCCParseNode>	the parent node in the parse tree


"
Class {
	#name : #SmaCCParseNode,
	#superclass : #Object,
	#instVars : [
		'parent',
		'attributes'
	],
	#category : 'SmaCC-Runtime'
}

{ #category : #accessing }
SmaCCParseNode class >> collectionVariableIn: aSmaCCParseNode collectionGetter: aSymbol variableGetter: varSymbol [
	(aSmaCCParseNode respondsTo: aSymbol)
		ifTrue: [ ^ aSmaCCParseNode perform: aSymbol ].
	(aSmaCCParseNode respondsTo: varSymbol)
		ifTrue: [ ^ Array with: (aSmaCCParseNode perform: varSymbol) ].
	^ #()
]

{ #category : #'instance creation' }
SmaCCParseNode class >> new [
	^ super new
		initialize;
		yourself
]

{ #category : #accessing }
SmaCCParseNode class >> variableIn: aSmaCCParseNode getter: aSymbol [
	(aSmaCCParseNode respondsTo: aSymbol)
		ifTrue: [ ^ aSmaCCParseNode perform: aSymbol ].
	^ nil
]

{ #category : #comparing }
SmaCCParseNode >> = anObject [
	^ self == anObject
		or:
			[ self class = anObject class
				and:
					[ self variableSelectors
						allSatisfy:
							[ :symbol | 
							(self perform: symbol)
								allSatisfy: [ :each | (self perform: each) = (anObject perform: each) ] ] ] ]
]

{ #category : #'visitor-double dispatching' }
SmaCCParseNode >> acceptVisitor: aSmaCCParseNodeVisitor [
	^ aSmaCCParseNodeVisitor visitSmaCCParseNode: self
]

{ #category : #'collection handling' }
SmaCCParseNode >> addFirstNode: aSmaCCParseNode to: aCollection [
	aSmaCCParseNode isNil
		ifTrue: [ ^ self ].
	aCollection addFirst: aSmaCCParseNode.
	aSmaCCParseNode parent: self
]

{ #category : #'collection handling' }
SmaCCParseNode >> addFirstNodes: aSmaCCParseNodeCollection to: aCollection [
	aSmaCCParseNodeCollection isNil
		ifTrue: [ ^ self ].
	aSmaCCParseNodeCollection
		reverseDo: [ :each | self addFirstNode: each to: aCollection ]
]

{ #category : #'collection handling' }
SmaCCParseNode >> addFirstObject: anObject to: aCollection [
	anObject isNil
		ifTrue: [ ^ self ].
	aCollection addFirst: anObject.
	(anObject isKindOf: SmaCCParseNode)
		ifTrue: [ anObject parent: self ]
]

{ #category : #'collection handling' }
SmaCCParseNode >> addFirstObjects: addCollection to: aCollection [
	addCollection isNil
		ifTrue: [ ^ self ].
	addCollection
		reverseDo: [ :each | self addFirstObject: each to: aCollection ]
]

{ #category : #'collection handling' }
SmaCCParseNode >> addFirstToken: aSmaCCToken to: aCollection [
	aSmaCCToken isNil
		ifTrue: [ ^ self ].
	aCollection addFirst: aSmaCCToken
]

{ #category : #'collection handling' }
SmaCCParseNode >> addFirstTokens: aSmaCCTokenCollection to: aCollection [
	aSmaCCTokenCollection isNil
		ifTrue: [ ^ self ].
	aCollection addAll: aSmaCCTokenCollection beforeIndex: 1
]

{ #category : #'collection handling' }
SmaCCParseNode >> addNode: aSmaCCParseNode to: aCollection [
	aSmaCCParseNode isNil
		ifTrue: [ ^ self ].
	aCollection add: aSmaCCParseNode.
	aSmaCCParseNode parent: self
]

{ #category : #'collection handling' }
SmaCCParseNode >> addNodes: aSmaCCParseNodeCollection to: aCollection [
	aSmaCCParseNodeCollection isNil
		ifTrue: [ ^ self ].
	aSmaCCParseNodeCollection
		do: [ :each | self addNode: each to: aCollection ]
]

{ #category : #'collection handling' }
SmaCCParseNode >> addObject: anObject to: aCollection [
	anObject isNil
		ifTrue: [ ^ self ].
	aCollection add: anObject.
	(anObject isKindOf: SmaCCParseNode)
		ifTrue: [ anObject parent: self ]
]

{ #category : #'collection handling' }
SmaCCParseNode >> addObjects: addCollection to: aCollection [
	addCollection isNil
		ifTrue: [ ^ self ].
	addCollection do: [ :each | self addObject: each to: aCollection ]
]

{ #category : #'collection handling' }
SmaCCParseNode >> addToken: aSmaCCToken to: aCollection [
	aSmaCCToken isNil
		ifTrue: [ ^ self ].
	aCollection add: aSmaCCToken
]

{ #category : #'collection handling' }
SmaCCParseNode >> addTokens: aSmaCCTokenCollection to: aCollection [
	aSmaCCTokenCollection isNil
		ifTrue: [ ^ self ].
	aCollection addAll: aSmaCCTokenCollection
]

{ #category : #iterating }
SmaCCParseNode >> allGettersDo: aBlock [
	self allVariableSelectors
		do: [ :sel | (self perform: sel) do: aBlock ]
]

{ #category : #iterating }
SmaCCParseNode >> allNodesDo: nodeBlock [
	self allNodesDo: nodeBlock andTokensDo: nil
]

{ #category : #iterating }
SmaCCParseNode >> allNodesDo: nodeBlock andTokensDo: tokenBlock [
	self
		nodesDo:
			[ :each | 
			nodeBlock value: each.
			each allNodesDo: nodeBlock andTokensDo: tokenBlock ]
		andTokensDo: tokenBlock
]

{ #category : #accessing }
SmaCCParseNode >> allTokens [
	| tokens |
	tokens := OrderedCollection new.
	self allTokensInto: tokens.
	^ tokens
		asSortedCollection: [ :a :b | a startPosition < b startPosition ]
]

{ #category : #accessing }
SmaCCParseNode >> allTokensInto: aCollection [
	self tokenVariables
		do:
			[ :each | (self perform: each) ifNotNil: [ :token | aCollection add: token ] ].
	self compositeTokenVariables
		do:
			[ :each | 
			(self perform: each)
				ifNotNil: [ :tokens | aCollection addAll: tokens ] ].
	self nodesDo: [ :each | each allTokensInto: aCollection ]
]

{ #category : #variables }
SmaCCParseNode >> allVariableSelectors [
	^ #(#tokenVariables #compositeTokenVariables #nodeVariables #compositeNodeVariables #otherVariables #ignoredTokenVariables #ignoredCompositeTokenVariables #ignoredNodeVariables #ignoredCompositeNodeVariables #ignoredOtherVariables)
]

{ #category : #'accessing-attributes' }
SmaCCParseNode >> attributeNamed: aSymbol [
	attributes isNil
		ifTrue: [ ^ nil ].
	^ attributes at: aSymbol ifAbsent: [ nil ]
]

{ #category : #'accessing-attributes' }
SmaCCParseNode >> attributeNamed: aSymbol ifAbsent: aBlock [
	^ self attributes at: aSymbol ifAbsent: aBlock
]

{ #category : #'accessing-attributes' }
SmaCCParseNode >> attributeNamed: aSymbol ifAbsentPut: aBlock [
	^ self attributes at: aSymbol ifAbsentPut: aBlock
]

{ #category : #'accessing-attributes' }
SmaCCParseNode >> attributeNamed: aSymbol put: aValue [
	^ self attributes at: aSymbol put: aValue
]

{ #category : #'accessing-attributes' }
SmaCCParseNode >> attributes [
	^ attributes ifNil: [ attributes := IdentityDictionary new ]
]

{ #category : #accessing }
SmaCCParseNode >> children [
	| result |
	result := OrderedCollection new.
	self
		nodesDo: [ :each | 
			each notNil
				ifTrue: [ result add: each ] ].
	^ result
]

{ #category : #accessing }
SmaCCParseNode >> comments [
	^ self attributeNamed: #comments
]

{ #category : #accessing }
SmaCCParseNode >> comments: anObject [
	self attributeNamed: #comments put: anObject
]

{ #category : #source }
SmaCCParseNode >> completeSource [
	^ parent isNil
		ifTrue: [ self attributeNamed: #source ]
		ifFalse: [ parent completeSource ]
]

{ #category : #source }
SmaCCParseNode >> completeSource: aString [
	^ parent isNil
		ifTrue:
			[ (Smalltalk at: #SmaCCString ifAbsent: [ nil ])
				ifNotNil:
					[ :stringClass | self attributeNamed: #source put: (stringClass on: aString) ] ]
		ifFalse: [ parent completeSource: aString ]
]

{ #category : #variables }
SmaCCParseNode >> compositeNodeVariables [
	^ #()
]

{ #category : #variables }
SmaCCParseNode >> compositeTokenVariables [
	^ #()
]

{ #category : #variables }
SmaCCParseNode >> compositeVariableSelectors [
	^ #(#compositeTokenVariables #compositeNodeVariables #ignoredCompositeTokenVariables #ignoredCompositeNodeVariables)
]

{ #category : #variables }
SmaCCParseNode >> compositeVariables [
	^ self compositeVariableSelectors
		inject: Set new
		into:
			[ :sum :each | 
			sum
				addAll: (self perform: each);
				yourself ]
]

{ #category : #matching }
SmaCCParseNode >> convertToSetter: selector [
	^ (selector , ':') asSymbol
]

{ #category : #matching }
SmaCCParseNode >> copyInContext: aDictionary [
	| copy |
	copy := self copy.
	self tokenVariables
		do:
			[ :selector | 
			copy
				perform: (self convertToSetter: selector)
				with: ((self perform: selector) copyInContext: aDictionary) ].
	self nodeVariables
		do:
			[ :selector | 
			copy
				perform: (self convertToSetter: selector)
				with: ((self perform: selector) copyInContext: aDictionary) ].
	self compositeTokenVariables
		do:
			[ :selector | 
			copy
				perform: (self convertToSetter: selector)
				with:
					((self perform: selector)
						collect: [ :each | each copyInContext: aDictionary ]) ].
	self compositeNodeVariables
		do:
			[ :selector | 
			copy
				perform: (self convertToSetter: selector)
				with:
					((self perform: selector)
						collect: [ :each | each copyInContext: aDictionary ]) ].
	^ copy
]

{ #category : #source }
SmaCCParseNode >> deleteSource [
	self completeSource
		deleteFrom: self startPosition
		to: self stopPosition
]

{ #category : #source }
SmaCCParseNode >> deleteToken: aSmaCCToken [
	self completeSource
		deleteFrom: aSmaCCToken startPosition
		to: aSmaCCToken stopPosition
]

{ #category : #accessing }
SmaCCParseNode >> filename [
	^ self attributeNamed: #filename
]

{ #category : #accessing }
SmaCCParseNode >> filename: aString [
	self attributeNamed: #filename put: aString
]

{ #category : #'initialize-release' }
SmaCCParseNode >> fixParentPointers [
	self
		nodesDo: [ :each | 
			each parent: self.
			each fixParentPointers ]
]

{ #category : #testing }
SmaCCParseNode >> hasDescendant: aSmaCCNode [
	^ aSmaCCNode isDescendantFrom: self
]

{ #category : #comparing }
SmaCCParseNode >> hash [
	^ self variableSelectors
		inject: self class hash
		into:
			[ :sum :symbol | 
			(self perform: symbol)
				inject: sum
				into:
					[ :hash :each | 
					| newHash |
					newHash := hash bitXor: (self perform: each) hash.
					((newHash bitShift: 1) bitAnd: SmallInteger maxVal)
						bitXor: (newHash bitShift: -29) ] ]
]

{ #category : #variables }
SmaCCParseNode >> ignoredCompositeNodeVariables [
	^ #()
]

{ #category : #variables }
SmaCCParseNode >> ignoredCompositeTokenVariables [
	^ #()
]

{ #category : #variables }
SmaCCParseNode >> ignoredNodeVariables [
	^ #()
]

{ #category : #variables }
SmaCCParseNode >> ignoredOtherVariables [
	^ #()
]

{ #category : #variables }
SmaCCParseNode >> ignoredTokenVariables [
	^ #()
]

{ #category : #source }
SmaCCParseNode >> insertSourceAfter: aString [
	self completeSource insert: aString at: self stopPosition + 1
]

{ #category : #source }
SmaCCParseNode >> insertSourceBefore: aString [
	self completeSource insert: aString at: self startPosition
]

{ #category : #source }
SmaCCParseNode >> insertSourceBefore: beginString andAfter: endString [
	self
		insertSourceBefore: beginString;
		insertSourceAfter: endString
]

{ #category : #testing }
SmaCCParseNode >> isDescendantFrom: aSmaCCNode [
	| current |
	current := self.
	[ current isNil or: [ current == aSmaCCNode ] ]
		whileFalse: [ current := current parent ].
	^ current notNil
]

{ #category : #testing }
SmaCCParseNode >> isListMatch [
	^ false
]

{ #category : #accessing }
SmaCCParseNode >> lookupNode: aBlock [
	| current |
	current := self.
	[ current isNil or: [ aBlock value: current ] ]
		whileFalse: [ current := current parent ].
	^ current
]

{ #category : #matching }
SmaCCParseNode >> match: aSmaCCParseNode inContext: aDictionary [
	self class = aSmaCCParseNode class
		ifFalse: [ ^ false ].
	(self
		matchVariables: self tokenVariables
		to: aSmaCCParseNode
		inContext: aDictionary)
		ifFalse: [ ^ false ].
	(self
		matchVariables: self nodeVariables
		to: aSmaCCParseNode
		inContext: aDictionary)
		ifFalse: [ ^ false ].
	(self
		matchCollectionVariables: self compositeTokenVariables
		to: aSmaCCParseNode
		inContext: aDictionary)
		ifFalse: [ ^ false ].
	^ self
		matchCollectionVariables: self compositeNodeVariables
		to: aSmaCCParseNode
		inContext: aDictionary
]

{ #category : #matching }
SmaCCParseNode >> matchCollection: matchNodes index: matchIndex to: programNodes index: programIndex inContext: aDictionary [
	| node currentIndex currentDictionary nodes |
	matchNodes size < matchIndex
		ifTrue: [ ^ programNodes size < programIndex ].
	node := matchNodes at: matchIndex.
	node isListMatch
		ifTrue:
			[ currentIndex := programIndex - 1.
			[ currentDictionary := aDictionary copy.
			programNodes size < currentIndex
				or:
					[ (self
						matchCollection: matchNodes
						index: matchIndex + 1
						to: programNodes
						index: currentIndex + 1
						inContext: currentDictionary)
						and:
							[ nodes := programNodes copyFrom: programIndex to: currentIndex.
							(node match: nodes inContext: currentDictionary)
								ifTrue:
									[ currentDictionary
										keysAndValuesDo: [ :key :value | aDictionary at: key put: value ].
									^ true ].
							false ] ] ] whileFalse: [ currentIndex := currentIndex + 1 ].
			^ false ].
	programNodes size < programIndex
		ifTrue: [ ^ false ].
	(node match: (programNodes at: programIndex) inContext: aDictionary)
		ifFalse: [ ^ false ].
	^ self
		matchCollection: matchNodes
		index: matchIndex + 1
		to: programNodes
		index: programIndex + 1
		inContext: aDictionary
]

{ #category : #matching }
SmaCCParseNode >> matchCollection: receiverCollection to: argumentCollection inContext: aDictionary [
	^ self
		matchCollection: receiverCollection
		index: 1
		to: argumentCollection
		index: 1
		inContext: aDictionary
]

{ #category : #matching }
SmaCCParseNode >> matchCollectionVariables: aCollection to: aSmaCCParseNode inContext: aDictionary [
	^ aCollection
		allSatisfy:
			[ :each | 
			self
				matchCollection: (self perform: each)
				to: (aSmaCCParseNode perform: each)
				inContext: aDictionary ]
]

{ #category : #matching }
SmaCCParseNode >> matchVariables: aCollection to: aSmaCCParseNode inContext: aDictionary [
	^ aCollection
		allSatisfy:
			[ :each | 
			| myValue otherValue |
			myValue := self perform: each.
			otherValue := aSmaCCParseNode perform: each.
			myValue isNil
				ifTrue: [ otherValue isNil ]
				ifFalse: [ myValue match: otherValue inContext: aDictionary ] ]
]

{ #category : #accessing }
SmaCCParseNode >> nodeOfType: aSmaCCParseNodeClassOrCollection [
	| isCollection |
	isCollection := aSmaCCParseNodeClassOrCollection isKindOf: Collection.
	^ self
		lookupNode:
			[ :each | 
			isCollection
				ifTrue:
					[ aSmaCCParseNodeClassOrCollection
						anySatisfy: [ :class | each isKindOf: class ] ]
				ifFalse: [ each isKindOf: aSmaCCParseNodeClassOrCollection ] ]
]

{ #category : #variables }
SmaCCParseNode >> nodeVariables [
	^ #()
]

{ #category : #iterating }
SmaCCParseNode >> nodesDo: nodeBlock [
	self nodesDo: nodeBlock andTokensDo: nil
]

{ #category : #iterating }
SmaCCParseNode >> nodesDo: nodeBlock andTokensDo: tokenBlock [
	| block |
	nodeBlock notNil
		ifTrue:
			[ block := [ :each | (self perform: each) ifNotNil: nodeBlock ].
			self nodeVariables do: block.
			self ignoredNodeVariables do: block.
			block := [ :each | (self perform: each) ifNotNil: [ :nodes | nodes do: nodeBlock ] ].
			self compositeNodeVariables do: block.
			self ignoredCompositeNodeVariables do: block ].
	tokenBlock notNil
		ifTrue:
			[ block := [ :each | (self perform: each) ifNotNil: tokenBlock ].
			self tokenVariables do: block.
			self ignoredTokenVariables do: block.
			block := [ :each | (self perform: each) ifNotNil: [ :nodes | nodes do: tokenBlock ] ].
			self compositeTokenVariables do: block.
			self ignoredCompositeTokenVariables do: block ].
	block := [ :each | 
	nodeBlock notNil
		ifTrue: [ (each isKindOf: SmaCCParseNode)
				ifTrue: [ nodeBlock value: each ] ].
	tokenBlock notNil
		ifTrue: [ (each isKindOf: SmaCCToken)
				ifTrue: [ tokenBlock value: each ] ].
	(each isKindOf: Collection)
		ifTrue: [ each do: block ] ].
	self otherVariables do: [ :sel | block value: (self perform: sel) ].
	self ignoredOtherVariables
		do: [ :sel | block value: (self perform: sel) ]
]

{ #category : #variables }
SmaCCParseNode >> otherVariables [
	^ #()
]

{ #category : #accessing }
SmaCCParseNode >> parent [
	^ parent
]

{ #category : #accessing }
SmaCCParseNode >> parent: aSmaCCParseNode [
	parent := aSmaCCParseNode
]

{ #category : #accessing }
SmaCCParseNode >> parentOfType: aSmaCCParseNodeClassOrCollection [
	^ parent notNil
		ifTrue: [ parent nodeOfType: aSmaCCParseNodeClassOrCollection ]
		ifFalse: [ nil ]
]

{ #category : #copying }
SmaCCParseNode >> postCopy [
	super postCopy.
	self
		allGettersDo:
			[ :each | 
			self
				perform: (self convertToSetter: each)
				with:
					((self compositeVariableSelectors includes: each)
						ifTrue: [ (self perform: each) collect: [ :item | item copy ] ]
						ifFalse: [ (self perform: each) copy ]) ]
]

{ #category : #printing }
SmaCCParseNode >> printOn: aStream [
	super printOn: aStream.
	self topParent completeSource notNil ifTrue: [ 
		aStream 
			nextPut: $(;
			nextPutAll: (self topParent completeSource copyFrom: self startPosition to: self stopPosition) asString;
			nextPut: $) ]
]

{ #category : #'accessing-attributes' }
SmaCCParseNode >> removeAttributeNamed: aSymbol [
	attributes isNil
		ifTrue: [ ^ self ].
	attributes removeKey: aSymbol ifAbsent: [  ]
]

{ #category : #accessing }
SmaCCParseNode >> removePositions [
	self removeAttributeNamed: #startPosition.
	self removeAttributeNamed: #stopPosition
]

{ #category : #replacing }
SmaCCParseNode >> replace: originalSmaCCParseNode with: newSmaCCParseNode [
	SmaCCParseNode instSize + 1 to: self class instSize do:
		[ :i | 
		| each |
		each := self instVarAt: i.
		each == originalSmaCCParseNode
			ifTrue: [ self instVarAt: i put: newSmaCCParseNode ]
			ifFalse:
				[ (each isKindOf: SequenceableCollection)
					ifTrue:
						[ each
							keysAndValuesDo:
								[ :index :value | 
								value == originalSmaCCParseNode
									ifTrue: [ each at: index put: newSmaCCParseNode ] ] ] ] ].
	self completeSource
		ifNotNil:
			[ :source | 
			source
				replaceFrom: originalSmaCCParseNode startPosition
				to: originalSmaCCParseNode stopPosition
				with: newSmaCCParseNode source ].
	newSmaCCParseNode parent: self
]

{ #category : #source }
SmaCCParseNode >> replaceToken: aSmaCCToken withSource: aString [
	self completeSource
		replaceFrom: aSmaCCToken startPosition
		to: aSmaCCToken stopPosition
		with: aString
]

{ #category : #replacing }
SmaCCParseNode >> replaceWith: aSmaCCParseNode [
	parent replace: self with: aSmaCCParseNode
]

{ #category : #source }
SmaCCParseNode >> replaceWithSource: aString [
	^ self completeSource
		replaceFrom: self startPosition
		to: self stopPosition
		with: aString
]

{ #category : #private }
SmaCCParseNode >> safePerform: aSymbol [
	^ (self respondsTo: aSymbol)
		ifTrue: [ self perform: aSymbol ]
		ifFalse: [ nil ]
]

{ #category : #'collection handling' }
SmaCCParseNode >> setParents: aCollection to: anObject [
	aCollection isNil
		ifTrue: [ ^ self ].
	aCollection do: [ :each | each parent: anObject ]
]

{ #category : #variables }
SmaCCParseNode >> singularVariableSelectors [
	^ #(#tokenVariables #nodeVariables #ignoredTokenVariables #ignoredNodeVariables #otherVariables #ignoredOtherVariables)
]

{ #category : #variables }
SmaCCParseNode >> singularVariables [
	^ self singularVariableSelectors
		inject: Set new
		into:
			[ :sum :each | 
			sum
				addAll: (self perform: each);
				yourself ]
]

{ #category : #accessing }
SmaCCParseNode >> sortedChildren [
	^ self children
		asSortedCollection:
			[ :a :b | 
			| startA startB |
			startA := a startPosition.
			startB := b startPosition.
			startA isNil
				or:
					[ b notNil
						and:
							[ startA class = startB class
								ifTrue: [ startA < startB ]
								ifFalse: [ startA class name < startB class name ] ] ] ]
]

{ #category : #source }
SmaCCParseNode >> source [
	^ self completeSource
		ifNotNil:
			[ :value | (value copyFrom: self startPosition to: self stopPosition) asString ]
]

{ #category : #accessing }
SmaCCParseNode >> startPosition [
	"Hackish way to get the minimum for all nodes. You might want to override to get a better implementation."

	^ self
		attributeNamed: #startPosition
		ifAbsentPut:
			[ | min doBlock |
			min := SmallInteger maxVal.
			doBlock := [ :each | each startPosition ifNotNil: [ :pos | min := min min: pos ] ].
			self nodesDo: doBlock andTokensDo: doBlock.
			min ]
]

{ #category : #accessing }
SmaCCParseNode >> stopPosition [
	"Hackish way to get the maximum for all nodes. You might want to override to get a better implementation."

	^ self
		attributeNamed: #stopPosition
		ifAbsentPut:
			[ | max doBlock |
			max := 0.
			doBlock := [ :each | each stopPosition ifNotNil: [ :pos | max := max max: pos ] ].
			self nodesDo: doBlock andTokensDo: doBlock.
			max ]
]

{ #category : #variables }
SmaCCParseNode >> tokenVariables [
	^ #()
]

{ #category : #accessing }
SmaCCParseNode >> topParent [
	| current |
	current := self.
	[ current parent notNil ] whileTrue: [ current := current parent ].
	^ current
]

{ #category : #variables }
SmaCCParseNode >> variableSelectors [
	^ #(#tokenVariables #compositeTokenVariables #nodeVariables #compositeNodeVariables #otherVariables)
]
